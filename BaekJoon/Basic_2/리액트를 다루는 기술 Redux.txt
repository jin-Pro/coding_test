# 리액트를 다루는 기술 - Redux #

- 리덕스로 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜서 효울적으로 관리할 수 있다.
- 컴포넌트끼리 상태를 공유해야 할 떄도 여러 컴포넌트를 거치지 않고 손쉽게 전달할 수 있다.

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

[ 액션 ]

- 상태에 변화가 필요하면 액션이 발생.
- 액션은 하나의 객체로 표현
- {type : 'TOGGLE_VALUE'}

[ 액션 생성 함수 ]

- 액션 객체를 만들어 주는 함수
- const changeInput = text => ({type : 'CHANGE_INPUT'});   ==>> type외에 내용은 action.으로 접근

[ 리듀서 ]

- 변화를 일으키는 함수
- 현재 상태와 액션 객체를 파라미터로 전달받음
- 액션에 따라 상태를 변화시켜줌

[ 스토어 ]

- 리덕스를 적용하기 위해 필요함
- 한 개의 프로젝트에는 한 개의 스토어가 필요하다
- 현재 애플리케이션 상태와 리듀서가 들어가야한다.

[ 디스패치 ]

- 스토어의 내장 함수
- 액션을 발생시키는 것
- dispatch({type : 'CHANGE_INPUT'})

[ 구독 ]

- 스토어의 내장 함수
- 액션이 디스패치되어 상태가 업데이트될 때마다 호출해줌.

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# 리덕스의 장점 #

- 모듈로 따로 분리하여 코드를 유지 보수하는데 도움이 된다.
- 실제 업데이트가 필요한 컴포넌트만 리렌더링되도록 최적화해 줄 수도 있다.

# 컨테이너 컴포넌트 #

- 리덕스와 연동되어 있는 컴포넌트
- 리덕스로부터 상태를 받아오거나 액션을 디스패치한다.

# 프레젠테이셔널 컴포넌트 #

- 컨테이너 컴포넌트에 props를 받아와서 ui만 보여준다.

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# 코드 작성법 #

- 액션 생성함수 폴더 => actions
- 액션 타입 폴더     => constants
- 리듀서 폴더        => reducers
or
- ducks 패턴 	     => 하나의 폴더에서 관리
		     => ducks 패턴으로 작성한 코드를 '모듈'이라 한다.

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# 코드 작성 순서 #

1. 액션 타입 정의 => const INCREASE = 'counter/INCREASE';
2. 액션 생성 함수 => export const increase = () => ({type : INCREASE});
3. 초기 state     => const initialState = { number : 0 }
4. 리듀서 작성    => export default function counter{state = initialState,action){
			switch(action.type){
				case INCREASE :
					return { number : state.number + 1}
			}
		     }
5. 루트 리듀서 작성     => const rootReducer = combineReducer({counter});    => modules/index.js
6. 스토어 만들기        => const store = createStore(rootReducer);	     => src/index.js
7. Provider 사용        => <Provider store = {store} >		     	     => src/index.js
8. 컨테이너컴포넌트작성 => 

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# redux-actions #

- 액션 쉽게 생성하기	=>	export const increase = createAction(INCREASE);
- reducer 쉽게 생성 	=> 	const counter = handleActions({ [INCREASE]: (state,action) => ({number : state.number +1 })),initalState,);

createAction => 간단하게 액션 생성 함수 선언
handleAction => 첫번째 파라미터에는 각 액션에 대한 업데이트 함수
	     => 두번째 파라미터에는 초기 상태

createAction으로 만든 액션 생성 함수는 파라미터로 받아 온 값을
객체 안에 넣을때 원하는 이름으로 넣는것이 아니라
payload라는 이름으로 값을 넣는다.

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# 리덕스 스토어와 연동 #

- useSelector로 상태 조회하기	=>	const number = useSelector(state => state.counter.number);
- useDispatch로 액션 디스패치	=>	const dispatch = useDispatch();		=>	dispatch({type : 'SAMPLE_ACTION'});

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

1. action 타입 정의	=>	const INCREASE = 'counyer/INCREASE';
2. action 생성함수	=>	export const increase = createAction(INCREASE);
3. initState 정의
4. HandleActions정의	=>	const counter = handleActions({
	== reducer			[INCREASE] : state => state + 1
				})
5. rootReducer 생성	=>	const rootReducer = combineReducers({counter})
6. store 생성		=>	const store = createStore(rootReducer);
7. Provider 생성	=>	<Provider store = {store} >

# 리덕스 미들웨어 #

- 액션을 디스패치했을 때 리듀서에서 처리하기 전에 지정된 작업을 처리해주기 위한 중간자
- 미들웨어는 함수를 반환하는 함수를 반환하는 함수이다.
- next(action)을 실행해야 다음 미들웨어 or 리듀서에 접근

[ 구조 ]

const loggerMiddleware = store => next => action =>{

};

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# redux-logger #

const logger = createLogger();	=>	src/index.js
const store = createStore(rootReducer,applyMiddleware(logger));

=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# redux-thunk #

- 비동기 작업을 처리할 때 가장 많이 사용
- 객체가 아닌 함수 형태의 액션을 디스패치 할 수 있다.
- 특정작업을 나중에 할 수 있도록 미루기 위함

[ 구조 ]

const sampleThunk = () => (dispatch,getState) => {

}

------

const store = createStore(rootReducer,applyMiddleware(logger,ReduxThunk));

-----

//액션 생성함수

export const increaseAsync = () => dispatch => {
	setTimeout(() => {
		dispatch(increase());
	},1000);
};

-----

[ promise 함수 ]

export const getUsers = () => async dispatch => {
	dispatch({type : GET_USERS});
	try{
		const response = await api.getUsers();
		dispatch({
			type : GET_USERS_SUCCESS,
			payload : response
		});
	}catch(e){
		dispatch({
			type :GET_USERS_FAILURE,
			payload : e,
			error : true
		})
	}
}

export const getPost = id => async dispatch =>{
	dispatch({type : GET_POST});
	try{
		const response = await api.getPost(id);
		dispatch({
			type : GET_POST_SUCCESS,
			payload : response
		})
	}catch(e){
		dispatch({
			type : GET_POST_FAILURE,
			payload : e
			error : true
		})
	}
}

=> 공통 부분이 많아서 리팩토링 진행

[ promise함수 리팩토링 ]

export default function createRequestThunk(type,request){
	const [SUCCESS,FAILURE] = [`$type`_SUCCESS,`$type`_FAILURE];

	return params => async dispatch => {

		dispatch({type})
		try{
			const response = await request(params);
			dispatch({
				type : SUCCESS,
				payload : response.data
			})
		}catch(e){
			dispatch({
				type : FAILURE,
				payload : e,
				error : true
			})
		}


export const getUsers = createRequestThunk(GET_USERS,api.getUsers);
export const getPost = createRequestThunk(GET_USERS,api.getPost);
=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# redux-saga #

- 비동기 작업 관련 라이브러리
- 특정 액션이 디스패치 되었을 때 정해진 로직에 따라 다른 액션을 디스패치 시킨다.
- 기존 요청을 취소해야 할 때
- API 요청 실패 시 재 요청해야 할 때
- (중요) 우리가 디스패치하는 액션을 모니터링해서 그에 따라 필요한 작업을 수행
- 제너레이터 함수 = saga

// 액션 타입 정의
const INCREASE_ASYNC = 'counter/INCREASE_ASYNC';

// 액션 생성 함수
export const increase = createAction(INCREASE);

// 액션 생성 함수
export const increaseAsync = createAction(INCREASE_ASYNC, () => undefined);

// 액션 saga (put == dispatch)	=> promisefunction
function* increaseSaga(){
	yield delay(1000);
	yield put(increase());
}

// 모니터링
export function* counterSaga(){
	yield takeEvery(INCREASE,ASYNC,increaseSaga);
}

// reducer
const counter = handleActions(
{
	[INCREASE] : state => state+1
}, initialState);

// rootSaga 생성
export function* rootSaga(){
	yield all([countSaga()]);
}

// store 적용
const sagaMiddleware = createSagaMiddleware();
const store = createStore(rootReducer,applyMiddleware(sagaMiddleware));
sagaMiddleware.run(rootSaga);

---------

// 액션 객체 정의
const GET_POST = 'sample/GET_POST';
const GET_POST_SUCCESS = 'sample/GET_POST_SUCCESS';
const GET_POST_FAILURE = 'sample/GET_POST_FAILURE';

const GET_USERS = 'sample/GET_USERS';
const GET_USERS_SUCCESS = 'sample/GET_USERS_SUCCESS';
const GET_USERS_FAILURE = 'sample/GET_USERS_FAILURE';

// 액션 생성 함수
export const getPost = createAction(GET_POST,id => id);
export const getUsers = creatAction(GET_USERS);

// api 요청 == promise 함수 ==> saga
function* getPostSaga(action){
	yield put(startLoading(GET_POST));
	try{
		//api.getPost(action.payload)
		const post = yield call(api.getPost,action.payload);

{
	type : 'sample/GET_POST',
	payload : 1
}


		yield put({
			type : GET_POST_SUCCESS,
			payload : post.data
		})
	}catch(e){
		yield put({
			type : GET_POST_FAILURE,
			payload : e,
			error : true
		})
	}
	yield put(finishLoading(GET_POST));
}
// api 요청 == promise 함수 ==> saga
function* getUsersSaga(){
	yield put(startLoading(GET_USERS));
	try{
		const users = yield call(api.getPost);
		yield put({
			type : GET_USERS_SUCCESS,
			payload : users.data
		})
	}catch(e){
		yield put({
			type : GET_USERS_FAILURE,
			payload : e
			error : true
		})
	}
	yield put(finishLoading(GET_USERS);
}

// 모니터

export function* sampleSaga(){
	yield takeLatest(GET_POST,getPostSaga);
	yield takeLatest(GET_USERS,getUsersSaga);

//reducer
const sample = handleActions({
	[GET_POST_SUCCESS] : (state,action) => ({
		...state,
		post : action.payload
	}),
	[GET_USERS_SUCCESS] : (state,action) => ({
		...state,
		users : action.payload
	})
}, initialState
);

[ 리팩토링 ]

function* getPostSaga(action){
	yield put(startLoading(GET_POST));
	try{
		//api.getPost(action.payload)
		const post = yield call(api.getPost,action.payload);

{
	type : 'sample/GET_POST',
	payload : 1
}


		yield put({
			type : GET_POST_SUCCESS,
			payload : post.data
		})
	}catch(e){
		yield put({
			type : GET_POST_FAILURE,
			payload : e,
			error : true
		})
	}
	yield put(finishLoading(GET_POST));
}
// api 요청 == promise 함수 ==> saga
function* getUsersSaga(){
	yield put(startLoading(GET_USERS));
	try{
		const users = yield call(api.getPost);
		yield put({
			type : GET_USERS_SUCCESS,
			payload : users.data
		})
	}catch(e){
		yield put({
			type : GET_USERS_FAILURE,
			payload : e
			error : true
		})
	}
	yield put(finishLoading(GET_USERS);
}

==>> 리팩토링

export default function createRequestSaga(type,request){
	const [SUCCESS,FAILURE] = [`${type}_SUCCESS`,`${type}_FAILURE`];
	
	return function*(action){
		yield put(startLoading(type));
		try{
			const res = yield call(request,action.payload);
			yield put(type : SUCCESS,payload : res.data);
		}catch(e){
			yield put(type : FAILURE,payload : e, error : true);
		}
		yield put(finishLoading(type));

const getPostSaga = createRequestSaga(GET_POST,api.getPost);
const getUsersSaga = createRequestSaga(GET_USERS,api.getUsers);


=============================
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=============================

# 사가 기능 #

call - api 호출
put - dispatch
select - 상태 확인	=>	const number = yield select(state => state.counter);
takeEvery - 모든 dispatch 모니터링
takeLatest - 마지막 dispatch만 모니터링













